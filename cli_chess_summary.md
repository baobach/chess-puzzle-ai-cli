## `cli-chess` UI Implementation Summary

The `cli-chess` project uses `prompt_toolkit` for its interactive terminal UI, which is a more advanced framework than `rich` for building full-screen terminal applications. While `rich` is excellent for rich text and tables, `prompt_toolkit` provides finer control over input, layout, and rendering, making it suitable for complex interactive interfaces like a chess game.

**Key Components for Board Rendering:**

1.  **`board_view.py`**: This file is responsible for the visual representation of the chessboard.
    *   It uses `prompt_toolkit.layout.Window` and `FormattedTextControl` to display the board.
    *   Crucially, it constructs the board output as an HTML-like string using `prompt_toolkit.formatted_text.HTML`. This allows for rich styling of individual squares and pieces.
    *   Each square's content includes the piece character and padding, and its style is determined by `square['square_display_color']` and `square['piece_display_color']`.
    *   It adds file and rank labels around the board.
    *   The `_build_output` method iterates through a `board_output_list` (which contains dictionaries for each square with details like `piece_str`, `square_display_color`, `piece_display_color`, `rank_label`, `is_end_of_rank`).

2.  **Styling (`styles.py`)**:
    *   `cli-chess` defines a comprehensive dictionary of styles in `src/cli_chess/utils/styles.py`. These styles are then referenced in the HTML-like strings generated by `board_view.py`.
    *   It uses specific style names like `"light-square"`, `"dark-square"`, `"light-square.light-piece"`, `"dark-square.dark-piece"`, etc., which are then mapped to `rich` (or `prompt_toolkit`) compatible color strings. This allows for highly customizable theming.

3.  **Piece Representation**:
    *   The `piece_str` in `board_output_list` is the actual Unicode character for the chess piece.
    *   The `_build_output` method adds a space after the `piece_str` (`piece_str += " " if square['piece_str'] else "  "`). This, combined with the fixed `width` of the `Window` (18 characters for 8 files, so about 2.25 chars per square), contributes to the spacing.

**Implications for Our Project:**

*   **`prompt_toolkit` vs. `rich`**: `cli-chess` uses `prompt_toolkit` for its UI, which offers more granular control over terminal layout and input than `rich`'s `Table` widget. While `rich` is simpler for basic table display, `prompt_toolkit` might be necessary to achieve the exact "square" look and interactive features of `cli-chess`.
*   **HTML-like Styling**: The use of `HTML` with `FormattedTextControl` in `prompt_toolkit` allows for very precise styling of each square and piece. We are currently using `rich`'s console markup, which is similar but might not offer the same level of control over cell dimensions and padding as `prompt_toolkit`'s `Window` and `Box` widgets.
*   **Fixed Dimensions**: `cli-chess` explicitly sets `width` and `height` for its `Window` and `Box` containers, which helps maintain consistent proportions regardless of terminal font. This is a key takeaway for achieving a truly "square" board.
*   **Piece Sizing**: The `cli-chess` project also acknowledges that the actual size of the chess piece icons is dependent on the terminal font. Their solution relies on setting appropriate cell dimensions and padding to make the pieces *appear* larger and the board well-proportioned.

**Conclusion:**

To achieve a UI similar to `cli-chess`, we would likely need to transition from `rich.table.Table` to `prompt_toolkit` for board rendering, or at least adopt `rich`'s lower-level layout primitives (like `rich.layout.Layout` and `rich.panel.Panel`) with more explicit control over dimensions and padding. The `cli-chess` approach of building the board as a formatted string with explicit HTML-like tags for styling is also a powerful technique.